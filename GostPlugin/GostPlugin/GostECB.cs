using System;
using System.Diagnostics;

namespace GostPlugin
{
    public static class GostECB
    {
        public const int BlockSize = 8; // 64-bit
        public const int KeyLength = 32; // 256-bit

        public static readonly byte[][] SBox_Test = {
            new byte[] { 0x03, 0x05, 0x0f, 0x07, 0x0c, 0x01, 0x0b, 0x06, 0x0e, 0x00, 0x08, 0x0d, 0x02, 0x09, 0x0a, 0x04 },
            new byte[] { 0x09, 0x05, 0x07, 0x00, 0x01, 0x08, 0x03, 0x02, 0x0a, 0x0f, 0x0d, 0x06, 0x0c, 0x04, 0x0b, 0x0e },
            new byte[] { 0x0b, 0x09, 0x00, 0x06, 0x07, 0x0c, 0x0f, 0x0e, 0x02, 0x04, 0x03, 0x0a, 0x0d, 0x01, 0x08, 0x05 },
            new byte[] { 0x03, 0x05, 0x02, 0x0b, 0x0c, 0x06, 0x04, 0x0e, 0x0f, 0x09, 0x08, 0x00, 0x01, 0x0a, 0x0d, 0x07 },
            new byte[] { 0x02, 0x0b, 0x03, 0x00, 0x0e, 0x09, 0x0a, 0x04, 0x08, 0x0d, 0x0f, 0x05, 0x01, 0x07, 0x0c, 0x06 },
            new byte[] { 0x0e, 0x0f, 0x0c, 0x09, 0x05, 0x08, 0x06, 0x03, 0x0d, 0x01, 0x02, 0x07, 0x00, 0x0a, 0x0b, 0x04 },
            new byte[] { 0x0c, 0x02, 0x08, 0x06, 0x07, 0x0e, 0x0a, 0x00, 0x09, 0x05, 0x0f, 0x03, 0x01, 0x04, 0x0b, 0x0d },
            new byte[] { 0x0c, 0x08, 0x0b, 0x06, 0x0e, 0x03, 0x02, 0x09, 0x04, 0x0a, 0x07, 0x05, 0x00, 0x0d, 0x0f, 0x01 }
        };

        public static readonly byte[][] SBox_CryptoPro_A = {
            new byte[] { 0x09, 0x06, 0x03, 0x02, 0x08, 0x0b, 0x01, 0x07, 0x0a, 0x04, 0x0e, 0x0f, 0x0c, 0x00, 0x0d, 0x05 },
            new byte[] { 0x03, 0x07, 0x0e, 0x09, 0x08, 0x0a, 0x0f, 0x00, 0x05, 0x02, 0x06, 0x0c, 0x0b, 0x04, 0x0d, 0x01 },
            new byte[] { 0x0e, 0x04, 0x06, 0x02, 0x0b, 0x03, 0x0d, 0x08, 0x0c, 0x0f, 0x05, 0x0a, 0x00, 0x07, 0x01, 0x09 },
            new byte[] { 0x0e, 0x07, 0x0a, 0x0c, 0x0d, 0x01, 0x03, 0x09, 0x00, 0x02, 0x0b, 0x04, 0x0f, 0x08, 0x05, 0x06 },
            new byte[] { 0x0b, 0x05, 0x01, 0x09, 0x08, 0x0d, 0x0f, 0x00, 0x0e, 0x04, 0x02, 0x03, 0x0c, 0x07, 0x0a, 0x06 },
            new byte[] { 0x03, 0x0a, 0x0d, 0x0c, 0x01, 0x02, 0x00, 0x0b, 0x07, 0x05, 0x09, 0x04, 0x08, 0x0f, 0x0e, 0x06 },
            new byte[] { 0x01, 0x0d, 0x02, 0x09, 0x07, 0x0a, 0x06, 0x00, 0x08, 0x0c, 0x04, 0x05, 0x0f, 0x03, 0x0b, 0x0e },
            new byte[] { 0x0b, 0x0a, 0x0f, 0x05, 0x00, 0x0c, 0x0e, 0x08, 0x06, 0x02, 0x03, 0x09, 0x01, 0x07, 0x0d, 0x04 }
        };

        public static byte[] Process(byte[] data, byte[] key, byte[][] sBox, bool encrypt)
        {
            Debug.Assert(data.Length == BlockSize, "BlockSize must be 64-bit long");
            Debug.Assert(key.Length == KeyLength, "Key must be 256-bit long");

            var a = BitConverter.ToUInt32(data, 0);
            var b = BitConverter.ToUInt32(data, 4);

            var subKeys = GetSubKeys(key);

            var result = new byte[8];

            for (int i = 0; i < 32; i++)
            {
                var keyIndex = GetKeyIndex(i, encrypt);
                var subKey = subKeys[keyIndex];
                var fValue = F(a, subKey, sBox);
                var round = b ^ fValue;
                if (i < 31)
                {
                    b = a;
                    a = round;
                }
                else
                {
                    b = round;
                }
            }

            Array.Copy(BitConverter.GetBytes(a), 0, result, 0, 4);
            Array.Copy(BitConverter.GetBytes(b), 0, result, 4, 4);

            return result;
        }

        private static uint F(uint block, uint subKey, byte[][] sBox)
        {
            block = (block + subKey) % uint.MaxValue;
            block = Substitute(block, sBox);
            block = (block << 11) | (block >> 21);
            return block;
        }

        private static uint Substitute(uint value, byte[][] sBox)
        {
            byte index, sBlock;
            uint result = 0;

            for (int i = 0; i < 8; i++)
            {
                index = (byte)(value >> (4 * i) & 0x0f);
                sBlock = sBox[i][index];
                result |= (uint)sBlock << (4 * i);
            }

            return result;
        }

        private static uint[] GetSubKeys(byte[] key)
        {
            var subKeys = new uint[8];
            for (int i = 0; i < 8; i++)
                subKeys[i] = (uint)BitConverter.ToUInt32(key, i * 4);
            return subKeys;
        }

        private static int GetKeyIndex(int i, bool encrypt)
        {
            return encrypt ? (i < 24) ? i % 8 : 7 - (i % 8)
                           : (i < 8) ? i % 8 : 7 - (i % 8);
        }
    }
}