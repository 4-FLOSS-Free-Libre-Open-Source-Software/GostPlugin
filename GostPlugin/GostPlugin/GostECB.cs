using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace GostPlugin
{
    public class GostECB
    {
        public const int BlockSize = 8; // 64-bit
        public const int KeyLength = 32; // 256-bit

        public static readonly byte[][] SBox_Test = {
            new byte[] { 0x04, 0x0a, 0x09, 0x02, 0x0d, 0x08, 0x00, 0x0e, 0x06, 0x0b, 0x01, 0x0c, 0x07, 0x0f, 0x05, 0x03 },
            new byte[] { 0x0e, 0x0b, 0x04, 0x0c, 0x06, 0x0d, 0x0f, 0x0a, 0x02, 0x03, 0x08, 0x01, 0x00, 0x07, 0x05, 0x09 },
            new byte[] { 0x05, 0x08, 0x01, 0x0d, 0x0a, 0x03, 0x04, 0x02, 0x0e, 0x0f, 0x0c, 0x07, 0x06, 0x00, 0x09, 0x0b },
            new byte[] { 0x07, 0x0d, 0x0a, 0x01, 0x00, 0x08, 0x09, 0x0f, 0x0e, 0x04, 0x06, 0x0c, 0x0b, 0x02, 0x05, 0x03 },
            new byte[] { 0x06, 0x0c, 0x07, 0x01, 0x05, 0x0f, 0x0d, 0x08, 0x04, 0x0a, 0x09, 0x0e, 0x00, 0x03, 0x0b, 0x02 },
            new byte[] { 0x04, 0x0b, 0x0a, 0x00, 0x07, 0x02, 0x01, 0x0d, 0x03, 0x06, 0x08, 0x05, 0x09, 0x0c, 0x0f, 0x0e },
            new byte[] { 0x0d, 0x0b, 0x04, 0x01, 0x03, 0x0f, 0x05, 0x09, 0x00, 0x0a, 0x0e, 0x07, 0x06, 0x08, 0x02, 0x0c },
            new byte[] { 0x01, 0x0f, 0x0d, 0x00, 0x05, 0x07, 0x0a, 0x04, 0x09, 0x02, 0x03, 0x0e, 0x06, 0x0b, 0x08, 0x0c }
        };

        public static readonly byte[][] SBox_CryptoProA = {
            new byte[] { 0x09, 0x06, 0x03, 0x02, 0x08, 0x0b, 0x01, 0x07, 0x0a, 0x04, 0x0e, 0x0f, 0x0c, 0x00, 0x0d, 0x05 },
            new byte[] { 0x03, 0x07, 0x0e, 0x09, 0x08, 0x0a, 0x0f, 0x00, 0x05, 0x02, 0x06, 0x0c, 0x0b, 0x04, 0x0d, 0x01 },
            new byte[] { 0x0e, 0x04, 0x06, 0x02, 0x0b, 0x03, 0x0d, 0x08, 0x0c, 0x0f, 0x05, 0x0a, 0x00, 0x07, 0x01, 0x09 },
            new byte[] { 0x0e, 0x07, 0x0a, 0x0c, 0x0d, 0x01, 0x03, 0x09, 0x00, 0x02, 0x0b, 0x04, 0x0f, 0x08, 0x05, 0x06 },
            new byte[] { 0x0b, 0x05, 0x01, 0x09, 0x08, 0x0d, 0x0f, 0x00, 0x0e, 0x04, 0x02, 0x03, 0x0c, 0x07, 0x0a, 0x06 },
            new byte[] { 0x03, 0x0a, 0x0d, 0x0c, 0x01, 0x02, 0x00, 0x0b, 0x07, 0x05, 0x09, 0x04, 0x08, 0x0f, 0x0e, 0x06 },
            new byte[] { 0x01, 0x0d, 0x02, 0x09, 0x07, 0x0a, 0x06, 0x00, 0x08, 0x0c, 0x04, 0x05, 0x0f, 0x03, 0x0b, 0x0e },
            new byte[] { 0x0b, 0x0a, 0x0f, 0x05, 0x00, 0x0c, 0x0e, 0x08, 0x06, 0x02, 0x03, 0x09, 0x01, 0x07, 0x0d, 0x04 }
        };

        [StructLayout(LayoutKind.Explicit)]
        private struct UnionSBoxOffsetIndex
        {
            [FieldOffset(0)]
            public uint data;

            [FieldOffset(0)]
            public byte i0;

            [FieldOffset(1)]
            public byte i1;

            [FieldOffset(2)]
            public byte i2;

            [FieldOffset(3)]
            public byte i3;
        }

        UnionSBoxOffsetIndex _offset = new UnionSBoxOffsetIndex();

        private uint[][] _sBox32;
        private uint[] _subKeys;

        public GostECB(byte[] key, byte[][] sBox = null)
        {
            ConvertSBox(sBox == null ? GostECB.SBox_CryptoProA : sBox);
            _subKeys = GetSubKeys(key);
        }

        private void ConvertSBox(byte[][] _sBox)
        {
            _sBox32 = new uint[4][];

            for (int i = 0, j = 0; i < 4; i++, j += 2)
            {
                _sBox32[i] = new uint[256];
                for (int k = 0; k < 256; k++)
                {
                    _sBox32[i][k] = (uint)((_sBox[j][k & 0x0f] ^ _sBox[j + 1][k >> 4] << 4) << (j * 4));
                    _sBox32[i][k] = _sBox32[i][k] << 11 ^ _sBox32[i][k] >> 21;
                }
            }
        }

        public byte[] Process(byte[] data)
        {
            Debug.Assert(data.Length == BlockSize, "BlockSize must be 64-bit long");

            var a = BitConverter.ToUInt32(data, 0);
            var b = BitConverter.ToUInt32(data, 4);

            var result = new byte[8];

            for (int i = 0; i < 32; i++)
            {
                var keyIndex = (i < 24) ? i % 8 : 7 - (i % 8);

                /*
                var subKey = subKeys[keyIndex];
                var fValue = F(a, subKey);
                var round = b ^ fValue;
                */

                var round = b ^ F(a, _subKeys[keyIndex]);

                b = a;
                a = round;

            }

            Array.Copy(BitConverter.GetBytes(b), 0, result, 0, 4);
            Array.Copy(BitConverter.GetBytes(a), 0, result, 4, 4);

            return result;
        }

        private uint F(uint block, uint subKey)
        {
            _offset.data = block + subKey;
            return
                _sBox32[0][_offset.i0] ^
                _sBox32[1][_offset.i1] ^
                _sBox32[2][_offset.i2] ^
                _sBox32[3][_offset.i3];
        }

        private uint[] GetSubKeys(byte[] key)
        {
            Debug.Assert(key.Length == KeyLength, "Key must be 256-bit long");
            var subKeys = new uint[8];
            for (int i = 0; i < 8; i++)
                subKeys[i] = (uint)BitConverter.ToUInt32(key, i * 4);
            return subKeys;
        }

    }
}